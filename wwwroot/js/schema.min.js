/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /gh/nuxodin/jema.js@1.2.0/schema.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const refKey = Symbol("ref"), defaultLocation = window?.location?.href || "http://localhost/"; let currentSchema = null, schemaStack = null, dataStack = null; export const AllSchemas = new Map; function loadSchema(e) { if (!AllSchemas.has(e)) { const t = fetch(e).then((e => e.json())).then((async t => { t.$id && t.$id !== e && console.warn("Schema id does not match url", t.$id, e), t.$id = e; const r = new Schema(t); return await r.deref(), r })); AllSchemas.set(e, t) } return AllSchemas.get(e) } export class Schema { constructor(e) { "object" == typeof e && (e.$schema ??= "https://json-schema.org/draft/2020-12/schema"), this.schema = e, this.id = e.$id, this.anchors = new Map([["", this.schema]]), this.dynAnchors = new Map, this.#e(this.schema) } async schemaErrors() { return (await loadSchema(this.schema.$schema)).errors(this.schema) } validate(e) { return this.errors(e).next().done } *errors(e) { return currentSchema = this, this.schemaStack = schemaStack = [], this.dataStack = dataStack = [], yield* errors(e, this.schema) } #e(e) { if (!e.$id || e.$id === this.id) { e.$anchor && !this.anchors.has(e.$anchor) && this.anchors.set(e.$anchor, e), e.$dynamicAnchor && !this.dynAnchors.has(e.$dynamicAnchor) && this.dynAnchors.set(e.$dynamicAnchor, e); for (const t of subSchemas(e)) this.#e(t) } } #t(e, t) { if (e.$id) { const r = new URL(e.$id, t); if (t = e.$id = r.toString(), !AllSchemas.has(r.href)) { const t = new Schema(e), n = new Promise((e => { queueMicrotask((() => { t.deref(), e(t) })) })); AllSchemas.set(r.href, n) } } for (const r of subSchemas(e)) this.#t(r, t) } async deref() { this.#t(this.schema, defaultLocation); const e = this.#r(this.schema); this.foraignSchemas = await promisesAllMap(e), this.#n(this.schema) } #n(e) { if (e.$ref && !e[refKey]) { const t = e.$ref, r = this.walk(t); null == r && console.error("$ref-schema not found", t, e), e[refKey] = r } if (e.$dynamicRef && !e[refKey]) { const t = e.$dynamicRef, r = this.walk(t); null == r && console.error("$dynamicRef-schema not found", t, e), e[refKey] = r } for (const t of subSchemas(e)) this.#n(t) } #r(e, t) { e.$id && (t = e.$id); const r = new Map; if (e.$ref && !e[refKey] && "#" !== e.$ref[0]) { const n = new URL(e.$ref, t).href.split("#")[0]; r.set(n, loadSchema(n)) } for (const n of subSchemas(e)) this.#r(n, t).forEach(((e, t) => r.set(t, e))); return r } walk(e, t) { if ("#" !== e[0]) { const { url: t, hash: r } = this.relativeUrl(e), n = this.foraignSchemas.get(t); return n ? n.walk(r) : void console.warn("foraignSchema not found", t, e) } const [r, ...n] = e.substring(1).split("/"); let a; if (a = t?.dynamic ? this.dynAnchors.get(r) : this.anchors.get(r) || this.dynAnchors.get(r), a) return walk(a, n) } relativeUrl(e) { const [t, r = ""] = new URL(e, this.id).href.split("#"); return { url: t, hash: "#" + r } } } function* subSchemas(e) { for (const [t, r] of Object.entries(e)) { const e = vocabulary[t]?.subSchema; if ("object" === e) for (const e of Object.values(r)) yield e; if ("array" === e) for (const e of r) yield e; !0 === e && (yield r) } } const evaluatedFor = new WeakMap; let stopCollectingEvaluated = !1; function* errors(e, t) { if (!1 === t) return void (yield schemaError(e, !1, "fails, false-schema at:")); if (!0 === t) return; const r = getType(e), n = unevaluatedNames[r]; n in t && (evaluatedFor.has(e) || evaluatedFor.set(e, new Set)); for (const n of Object.keys(t)) { const a = vocabulary[n]; if (!a || a.affects && a.affects !== r) continue; const s = a?.valid; s && (schemaStack.push(n), s instanceof GeneratorFunction ? yield* s(t[n], e, t) : s(t[n], e, t) || (yield schemaError(e, t[n])), schemaStack.pop()) } if (typeValidators[r] && (yield* typeValidators[r](t, e)), n in t) { const a = evaluatedFor.get(e); if (a) { const s = "object" === r ? Object.keys(e) : e.keys(); for (const r of s) a.has(r) || (yield* errors(e[r], t[n])); evaluatedFor.delete(e) } } } const typeValidators = { *object(e, t) { const r = e.properties, n = e.patternProperties && Object.entries(e.patternProperties), a = e.additionalProperties; for (const [e, s] of Object.entries(t)) { dataStack.push(e); let i = !0; const o = r?.[e]; if (null != o && (schemaStack.push("properties", e), yield* errors(s, o), schemaStack.pop(), schemaStack.pop(), i = !1), n) { schemaStack.push("patternProperties", e); for (const [t, r] of n) new RegExp(t, "u").test(e) && (yield* errors(s, r), i = !1); schemaStack.pop(), schemaStack.pop() } null != a && i && (schemaStack.push("additionalProperties"), yield* errors(s, a), schemaStack.pop(), i = !1), i || stopCollectingEvaluated || evaluatedFor.get(t)?.add(e), dataStack.pop() } }, *array(e, t) { let r = 0; for (const [n, a] of t.entries()) { dataStack.push(n); let s = !0; if (null != e.prefixItems?.[n]) yield* errors(a, e.prefixItems[n]), s = !1; else if (null != e.items) { for (const r of errors(a, e.items)) evaluatedFor.get(t)?.clear(), yield r; s = !1 } if (null != e.contains) { errors(a, e.contains).next().done && (r++, s = !1) } s || stopCollectingEvaluated || evaluatedFor.get(t)?.add(n), dataStack.pop() } if (null != e.contains) { const t = e.minContains ?? 1, n = e.maxContains ?? 1 / 0; r < t && (yield 'Array contains too few items that match "contains"'), r > n && (yield 'Array contains too many items that match "contains"') } } }, vocabulary = { $schema: {}, $vocabulary: {}, $id: {}, $anchor: {}, $dynamicAnchor: {}, $ref: { *valid(e, t, r) { return null == r[refKey] && console.error("dynamicRef: no schema found, deref() called?", e), yield* errors(t, r[refKey]) } }, $dynamicRef: { *valid(e, t, r) { const n = currentSchema.walk(e, { dynamic: !0 }) || r[refKey]; return null == n && console.error("dynamicRef: no schema found, deref() called?", e, currentSchema), yield* errors(t, n) } }, $defs: { subSchema: "object" }, allOf: { *valid(e, t) { for (const [r, n] of e.entries()) schemaStack.push(r), yield* errors(t, n), schemaStack.pop() }, subSchema: "array" }, anyOf: { valid(e, t) { const r = evaluatedFor.has(t); let n = !1; for (const a of e) { if (errors(t, a).next().done) { if (!r) return !0; n = !0 } } return n }, subSchema: "array" }, oneOf: { valid(e, t) { let r = 0; for (const n of e) if (r += errors(t, n).next().done ? 1 : 0, r > 1) return !1; return 1 === r }, subSchema: "array" }, not: { valid(e, t) { stopCollectingEvaluated = !0; const r = errors(t, e).next().done; return schemaStack.pop(), stopCollectingEvaluated = !1, !r }, subSchema: !0 }, if: { *valid(e, t, r) { const n = errors(t, e).next().done; schemaStack.pop(), n ? (schemaStack.push("then"), null != r.then && (yield* errors(t, r.then))) : (schemaStack.push("else"), null != r.else && (yield* errors(t, r.else))), schemaStack.pop() }, subSchema: !0 }, then: { subSchema: !0 }, else: { subSchema: !0 }, type: { valid(e, t) { if (Array.isArray(e)) { for (const r of e) if (vocabulary.type.valid(r, t)) return !0; return } const r = getType(t); return r === e || (!("integer" !== e || "number" !== r || !Number.isInteger(t)) || void 0) } }, enum: { valid(e, t) { for (const r of e) if (deepEqual(r, t)) return !0 } }, const: { valid: (e, t) => deepEqual(e, t) }, multipleOf: { valid(e, t) { const r = t / e; return Number.isFinite(r) && r * e == Math.round(r) * e }, affects: "number" }, maximum: { valid: (e, t) => t <= e, affects: "number" }, exclusiveMaximum: { valid: (e, t) => t < e, affects: "number" }, minimum: { valid: (e, t) => t >= e, affects: "number" }, exclusiveMinimum: { valid: (e, t) => t > e, affects: "number" }, maxLength: { valid: (e, t) => [...t].length <= e, affects: "string" }, minLength: { valid: (e, t) => [...t].length >= e, affects: "string" }, pattern: { valid: (e, t) => new RegExp(e, "u").test(t), affects: "string" }, format: { valid: (e, t) => !0, affects: "string" }, maxItems: { valid: (e, t) => t.length <= e, affects: "array" }, minItems: { valid: (e, t) => t.length >= e, affects: "array" }, uniqueItems: { valid: (e, t) => { if (!e) return !0; const r = new Set; for (const e of t) { const t = uniqueValueIgnoreKeyOrder(e); if (r.has(t)) return !1; r.add(t) } return !0 }, affects: "array" }, items: { subSchema: !0 }, additionalItems: { subSchema: !0 }, contains: { subSchema: !0 }, prefixItems: { subSchema: "array" }, unevaluatedItems: { subSchema: !0 }, properties: { subSchema: "object" }, additionalProperties: { subSchema: !0 }, unevaluatedProperties: { subSchema: !0 }, patternProperties: { subSchema: !0 }, maxProperties: { valid: (e, t) => Object.keys(t).length <= e, affects: "object" }, minProperties: { valid: (e, t) => Object.keys(t).length >= e, affects: "object" }, required: { *valid(e, t) { for (const [r, n] of e.entries()) Object.hasOwn(t, n) || (schemaStack.push(r), yield schemaError(t, n, "missing required property"), schemaStack.pop()) }, affects: "object", subSchema: !0 }, dependentRequired: { valid: (e, t) => { for (const [r, n] of Object.entries(e)) if (Object.hasOwn(t, r)) for (const e of n) if (!Object.hasOwn(t, e)) return !1; return !0 }, affects: "object" }, dependentSchemas: { *valid(e, t) { for (const [r, n] of Object.entries(e)) Object.hasOwn(t, r) && (yield* errors(t, n)) }, affects: "object", subSchema: !0 }, dependencies: { *valid(e, t) { for (const [r, n] of Object.entries(e)) if (Object.hasOwn(t, r)) if (Array.isArray(n)) for (const e of n) Object.hasOwn(t, e) || (yield schemaError(t, e, "missing required property")); else yield* errors(t, n) } }, propertyNames: { *valid(e, t) { for (const r of Object.keys(t)) yield* errors(r, e) }, affects: "object", subSchema: !0 } }; function schemaError(e, t, r = "does not match") { return { message: `${Array.isArray(e) ? "array" : "object" == typeof e ? "object" : '"' + e + '"'} ${r} ${schemaStack.at(-1)}:${t}`, value: e, schemaValue: t, schemaStack: [...schemaStack], dataStack: [...dataStack] } } function getType(e) { if (null == e) return "null"; const t = typeof e; return "number" !== t || isFinite(e) ? "object" === t && Array.isArray(e) ? "array" : t : "not supported" } const unevaluatedNames = { object: "unevaluatedProperties", array: "unevaluatedItems" }; function validDate(e) { const t = e.match(/^(\d{4})-(\d{2})-(\d{2})$/); if (!t) return !1; const [r, n, a] = t.slice(1); if (n > 12) return !1; if (a > 31) return !1; if (a > 28) { if (a > new Date(r, n, 0).getDate()) return !1 } return !0 } function validTime(e) { const t = e.match(/^(\d{2}):(\d{2}):(\d{2})(?:\.\d+)?(?:Z|([\+-]\d{2}):(\d{2}))$/i); if (!t) return !1; const [r, n, a, s, i] = t.slice(1); if (r > 23) return !1; if (n > 59) return !1; if (a > 60) return !1; if (null != s) { if (s > 23) return !1; if (s < -23) return !1; if (void 0 === i) return !1; if (i > 59) return !1 } if ("60" == a) { const e = 1 * n - (i || 0), t = 1 * r - (s || 0); if (59 !== e && -1 !== e) return !1; if (23 !== t && 0 !== t) return !1 } return !0 } function validDateTime(e) { const [t, r] = e.split(/T/i); return !!validDate(t) && !!validTime(r) } function isValidHostname(e) { if (!e || e.length > 255) return !1; if (!/^[a-zA-Z0-9\-.]+$/.test(e)) return !1; const t = e.split("."); for (const e of t) { if (!e || e.length > 63) return !1; if ("-" === e[0] || "-" === e.at(-1)) return !1 } return !0 } function isValidIdnHostname(e) { try { new URL("http://" + e) } catch { return !1 } for (let t of e.split(".")) { if (t = t.toLowerCase(), t.length > 63) return !1; if ("--" === t.substring(2, 4)) return !1; if (t.startsWith("-") || t.endsWith("-")) return !1; if (t.match(/(?<!.)\u05F4/)) return !1; if (t.match(/(?<![\p{Script=Hebrew}])\u05F3/u)) return !1; if (t.match(/\u0375(?![\p{Script=Greek}])/u)) return !1; if (t.includes("〮")) return !1; if ((t.includes("・") || t.includes("·")) && !/[\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}]/u.test(t)) return !1 } return !0 } function isValidIPv4(e) { return /^((?!0\d)\d{1,3}\.){3}(?!0\d)\d{1,3}$/.test(e) && e.split(".").every((e => e >= 0 && e <= 255)) } function isValidIPv6(e) { try { return new URL(`http://[${e}]`), !0 } catch { return !1 } } function isValidEmail(e, t) { const r = e.lastIndexOf("@"), n = e.substring(0, r), a = e.substring(r + 1); if ("" === n) return !1; if ("[" === a[0] && "]" === a.at(-1)) { if (a.startsWith("[IPv6:")) { if (!isValidIPv6(a.slice(6, -1))) return !1 } else if (!isValidIPv4(a.slice(1, -1))) return !1 } else if (t) { if (!isValidIdnHostname(a)) return !1 } else if (!isValidHostname(a)) return !1; return /^(?!\.)("([^"\r\\]|\\["\r\\])*"|([-a-z0-9!#$%&'*+/=?^_`{|}~]|(?<!\.)\.)*)(?<!\.)$/.test(n) } function parseDuration(e) { const [t, r] = e.split("T"), n = t.match(/^P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?$/); if (!n) return null; const [, a, s, i, o] = n; if (null != i && (null != a || null != s || null != o)) return null; if ("" === r) return null; const c = r?.match(/^(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/) ?? [], [, l, u, f] = c; return null == a && null == s && null == i && null == o && null == l && null == u && null == f ? null : { years: a, months: s, weeks: i, days: o, hours: l, minutes: u, seconds: f } } function walk(e, t) { let r = e; for (let n of t) { if (n = n.replace(/~1/g, "/").replace(/~0/g, "~").replace(/%25/g, "%").replace(/%22/g, '"'), !(n in r)) return void console.warn(`path '${t.join("/")}' not found in schema`, e); r = r[n] } return r } function deepEqual(e, t) { if (e === t) return !0; if (null == e && null != t) return !1; if (null != e && null == t) return !1; if ("object" == typeof e && "object" == typeof t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; for (let r = 0; r < e.length; r++)if (!deepEqual(e[r], t[r])) return !1; return !0 } { const r = Object.keys(e), n = Object.keys(t); if (r.length !== n.length) return !1; for (const n of r) if (!deepEqual(e[n], t[n])) return !1; return !0 } } return !1 } async function promisesAllMap(e) { const t = await Promise.all(e.values()), r = new Map; for (const [n] of e) r.set(n, t.shift()); return r } function uniqueValueIgnoreKeyOrder(e) { if (null == e || "object" != typeof e) return e; const t = deepCopyObjectAndOrderKeys(e); return "hopeNoOneWillEverUseString" + JSON.stringify(t) } function deepCopyObjectAndOrderKeys(e) { if (null == e || "object" != typeof e) return e; if (Array.isArray(e)) return e.map(deepCopyObjectAndOrderKeys); const t = {}; for (const r of Object.keys(e).sort()) t[r] = deepCopyObjectAndOrderKeys(e[r]); return t } const GeneratorFunction = function* () { }.constructor;
//# sourceMappingURL=/sm/557583675bf5ad5e324597b3a02a2da43f2dd84c53244f93490e4597ab03ab35.map